---
title: "Módulo 3: Aplicación de estructuras en programación"
author: "Guillermo S. Fuentes Jaque"
date: "August 18, 2021"
output:
  html_document:
    highlight: haddock
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: true
---

<style>
  body {text-align: justify;font-family: sans-serif;}
  #header {text-align: center;}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(global.device = TRUE)
Sys.setenv(LANG = "es")
```

<br>

# Estructuras en la programación
## Consideraciones y conceptos básicos
Antes de iniciar con la actividad de hoy es fundamental conocer un poco del vocabulario usado en este lenguaje de programación. algunos conceptos básicos tienen una nomenclatura en concreto que deberíamos manejar como lenguaje con común para que no hayan confusiones al momento de desarrollar las actividad.

### Ejecución y devolución

Cuando hablamos del concepto **ejecutar**, **llamar** o **correr** nos referimos a pedir que R realice algo, en otras palabras, estamos dando una **instrucción** o una **entrada **.

Cuando hablamos de **línea de código**, hacemos referencia a cada linea con **instrucciones** específicas, las cuales pueden ser simples o complejas, dependiendo de cuantas instrucciones concatenadas se les haya incluido.

Cuando decimos que R nos **devuelve** algo, es que ha realizado algo que le hemos pedido, es decir, nos está dando una **salida* o respuesta de la instrucción solicitada.

Por ejemplo, si escribimos la línea de código siguiente en la consola y en seguida presionamos *enter*, estamos pidiendo que se ejecute la operación `1 + 1`, ello nos devolverá su resultado que es `[1] 2`. Es así que el la primera parte estamos ejecutando o corriendo una linea de código, mientras que la consola nos devuelve o retorna el resultado.
```{r}
# Ejecutamos una suma
1+1
```

Por otro lado Una función, a grandes rasgos, es una serie de operaciones a las que les hemos asignados un nombre. Las funciones aceptan argumentos, es decir, especificaciones sobre cómo deben funcionar. Cuando llamamos una función, se realizan las operaciones que ésta contiene, usando los argumentos que hemos establecido.

### directorios

El **directorio** o carpeta de trabajo es el lugar en nuestra computadora en el que se encuentran los archivos con los que estamos trabajando en R. Este es el lugar donde R buscara archivos para importarlos y al que serán exportados, a menos que indiquemos otra cosa.

Cómo ya habrán visto en la clase anterior, pueden encontrar cuál es el directorio de trabajo con la función `getwd()`, mientras que para cambiar el directorio de trabajo se utiliza `setwd()`, donde el principal argumento corresponde a la ruta en que trabajarán.
```{r}
# revisamos el directorio de trabajo
getwd()
```
```{r,eval=FALSE}
# definimos un nuevo directorio raiz
setwd("G:/nuevo directorio")
```

En el próximo módulo podrán estudiar más en detalle esta funciones y sus parámetros, así como también, podrán manipular ficheros y directorios para un trabajo más eficiente.

### Paquetes

R puede ser expandido con **paquetes** o **bibliotecas** que permiten una manipulación más eficiente de la programación en función de sus objetivos específicos. Cada paquete es una colección de funciones diseñadas para atender una tarea específica. Por ejemplo, hay paquetes para trabajo visualización geoespacial, análisis psicométricos, minería de datos, interacción con servicios de Internet y muchas otras cosas más.

Podemos instalar paquetes usando la función `install.packages()`, dando como argumento el nombre del paquete que deseamos instalar, entre comillas. Una vez concluida la instalación de un paquete, debemos cargarla en nuestro ambiente de trabajo, para así, poder usar sus funciones, esto se hace llamando a la función `library()` o `require()`, el único argumento necesario en esta función, será el nombre del paquete que queramos utilizar.
```{r, eval=FALSE}
# instalamos paquetes
install.packages(c("raster","rgdal"))
```

```{r}
# Cargamos paquetes
library(raster)
library(rgdal)
```

Por último, haremos referencia al concepto de **script**, los *scripts* son documentos de texto plano como cualquier otro documentos de texto, pero que permite la lectura y ejecución de las lineas de código R contenidas en éste.

## Esquema de estructuración

Como ya habrán podido darse cuenta durante el desarrollo del curso, al momento de generar un script, éste se ejecuta de manera secuencial, y por lo tanto es necesario definir una estructura lógica para si escritura. Existen muchas formas en que pueden estructurar los script, a continuación, se les plantea uno de los esquemas más extendidos en el mundo de la programación.

Es posible diferenciar 3 bloques bien definidos que se aprecian en la imagen siguiente y que pasaremos a detallar a continuación.

![](https://djwillichile.github.io/MODULO_03/IMG/ESTRUCTURA.png){width='100%'}

### Header o cabecera
Corresponde al bloque en que se desea configurar el ambiente del *script* que se está escribiendo. En éste bloque se limpia la consola en caso ser necesario, se cargan los paquetes a utilizar (caso de no tenerlos instalados es necesario llamar a la función para instalar el paquete antes de cargarlo), se definen las funciones que se utilizarán más adelante en el script y se define el directorio de trabajo.

### main o cuerpo principal
Corresponde al bloque en el que se desarrollará la gran mayoría del código, en éste se cargarán los datos, constantes o variables de entrada (o iniciales) necesarias para desarrollar los procesos, se escriben los procesos a realizar en función de las operaciones aritméticas y lógicas definidas por las diversas estructuras de control (de las cuales hablaremos en unos instantes) y por último se guardarán los resultados de los procesos, exportándolos a sus respectivos formatos de salida.

### Foother o piecera
Por último, éste bloque busca cerrar todo proceso que haya quedado abierto en los bloques anteriores, permite liberar los recursos utilizados en los procesos desarrollados por el programa ejecutado y evitar un mal uso de la memoria virtual y física. Realizar este ultimo paso, se considera una buena práctica en el mundo de la programación.

A continuación podemos observar un esquema en el que es posible encontrar los 3 bloques mencionados de la estructura planteada, recordar que es solo un script de ejemplo para visualizar la estructura, algunas funciones aun no las hemos visto, pero las describiremos más adelante en el curso.

```{r, eval=FALSE}
#esto es solo un ejemplo, no correr si no es necesario

#limpiar entorno de trabajo
rm(ls())
gc()

# instalamos paquetes
install.packages("stats")

# cargamos paquetes
library("stats")

#creamos funciones en este caso la moda
statMode=function(x){
  if(all(x==as.integer(x))|is.character(x)){
    tab=table(x)
    val=tab[[which.max(tab)]]
    return(val)
  }
  if(is.double(x)){
    tab=density(x)
    val=tab$x[which.max(tab$y)]
    return(val)
  }
}

# definimos un nuevo directorio raiz
setwd("G:/nuevo directorio")

produccion=c(120,100,132,112,95,164,172,183,155,176,110,115,122,108,120)


x=c(20, 20.3, 21, 20, 19, 20, 19, 19, 20, 21,20, 20, 19, 19, 20, 20)



```



## Estructuras de control
Anteriormente mencionamos que las operaciones que se desarrollan en el *main* estaban definidas por las estructuras de control, justamente, como su nombre lo indica, éstas permiten controlar la manera en que se ejecuta nuestro programa.

Las estructuras de control establecen condiciones y rutinas para la ejecución del código. Un ejemplo de esto sería indicar las condiciones que se deben cumplir para realizar una operación aritmética o las necesarias para ejecutar una función en particular.

Esto es de gran utilidad para determinar la lógica y el orden en que ocurren las operaciones, en especial al definir funciones.

![](https://djwillichile.github.io/MODULO_03/IMG/CONTROL.jpg){width='100%'}

Es posible reconocer 3 principales tipos de estructuras de control, por un lado tenemos las estructuras de **secuencia**, la cuale se caracterizan por ser el tipo de estructura mas simple y consta de ejecutar instrucciones en un orden especifico, una tras otra, este tipo de estructura se puede agrupar en 3 tipos de algoritos, **Asignación**, **Entrada** y **Salida**.

Las estructuras *condicionales* o de desición, por otro lado, son estructuras que  permiten seleccionar la rama del código a ejecutar dependiendo de la falsedad o veracidad de una o varias expresiones lógicas, dicho resultado sera utilizado por una estructura condicional para desviar el flujo de ejecución de un programa, es decir, si la condicion es verdadera se hace una cosa y si es falsa se hace otra. la estructura condicional se puede clasificar cómo **simple** (una respuesta si es verdadero y otra si es falso) o **compleja** (dependiendo de la desición se tomaráuna rama u otra).

Esta estructura la podemos observar en nuestra vida cotidiana talcomo lo podemos observar en el siguiente diagrama

![](https://djwillichile.github.io/MODULO_03/IMG/CONDICIONAL.jpg){width='100%'}

Por último, la estructura de **bucle**, ciclica o también llamada iterativa cumplen la función de ejecutar un bloque de código un numero definido de veces, es decir como su nombre lo dice, repiten las mismas lineas de código una y otra vez según sea necesario. Podemos identificar 3 tipos de estructuras cíclicas, las que se ejecutan mientras se siga cumpliendo una condición, aquellas que se ejecutan hasta que se cumple una condición o las que se ejecutan una cantidad definida de veces.


Las estructuras de control más usadas en R son las siguientes.

Existe un gran número de formatos en que se puede importar datos, un ejemplo de estos es el ya conocido **csv** (*Comma Separated Values*), o el versátil **xlsx** de Excel, a continuación se importarán datos desde los formatos csv, xlsx, shp y kml. Para estos ejemplos utilizaremos los materiales encontrados en el repositorio <https://github.com/djwillichile/MODULO_05/tree/gh-pages/DATA>, también pueden acceder a todo el material utilizado para esta actividad mediante el siguiente **[enlace](https://djwillichile.github.io/MODULO_05/DATA/Materiales.zip)**.

## importar datos desde csv
Este método es uno de los más sencillos de implementar y a la vez, el que permite más formas distintas de realizarlo. utilizaremos el archivo *bradypus.csv*

```{r, include = T,eval=T}
# Asignamos al objeto "path" la ruta del archivo que utilizaremos
path <- "https://djwillichile.github.io/MODULO_05/DATA"

# Asignamos al objeto "file" el nombre del archivo que utilizaremos
file <- "bradypus.csv"

#ruta completa del archivo
fileStrig <- paste0(path,"/",file)
fileStrig

# Leemos el archivo mediante la función "read.csv"
bradypus <- read.csv(file = fileStrig)

# Es posible observar una porcion de los datos cargados
head(bradypus)

```



Cabe destacar que es posible leer estos datos utilizando también la función `read.table()` o `read.delim()`

```{r}
# Leemos el archivo mediante la función "read.table"
bradypus <- read.table(file = fileStrig,sep = ",",dec = ".",header = T)
head(bradypus)

# Leemos el archivo mediante la función "read.delim"
bradypus <- read.delim(file = fileStrig,sep = ",",dec = ".",header = T)
head(bradypus)
```

## Otros formatos para importar
Así como importamos la base de datos a partir de un *csv* que contenía la información, también es posible utilizar distintas extensiones de archivos, como por ejemplo los textos delimitados por tabulación (*txt*), la extensión de Microsoft Excel (*xls* o *xlsx*) o extensiones más conocidas en el mundo del análisis espacial como lo son el Keyhole Markup Language (*kml*) de Google Earth o el Shape File (*shp*) de ESRI, los cuales veremos más a delante.

Para las primeras 3 extensiones, la manera en que se pueden cargar los archivos son relativamente parecidas, la gran diferencia es que el texto delimitado por tabulación no necesita de paquetes externos al de *r base* para su importación.
A continuación veremos de manera muy resumida como importar la misma base de datos proveniente de distintos ficheros con estas 3 extensiones.

### textos delimitados por tabilación (*txt*)
```{r}
# Asignamos al objeto "fileStrig" ruta completa del archivo
fileStrig <- "https://djwillichile.github.io/MODULO_05/DATA/bradypus.txt"

# Leemos el archivo mediante la función "read.table"
bradypus <- read.table(file = fileStrig,sep = "\t",dec = ".",header = T)
head(bradypus)

# Leemos el archivo mediante la función "read.delim"
bradypus <- read.delim(file = fileStrig,sep = "\t",dec = ".",header = T)
head(bradypus)
```

### libro de Microsoft Excel 1997-2003 (*xls*)
```{r}
# cargamos paquete para soportar el formato
library(readxl)

# creamos un archivo temporal en el objeto "temp"
temp <- tempfile(fileext = ".xls")

# Asignamos al objeto "fileStrig" ruta completa del archivo y lo descargamos
fileStrig <- "https://djwillichile.github.io/MODULO_05/DATA/bradypus.xls"
curl::curl_download(fileStrig, temp) # descargar el fichero en el archivo temporal 

# Leemos el archivo temporal mediante la función "read_excel"
bradypus <- read_excel(temp,1)
head(bradypus)
```

### libro de Microsoft Excel (*xlsx*)
```{r}
# cargamos paquete para soportar el formato
library(openxlsx)

# Asignamos al objeto "fileStrig" ruta completa del archivo
fileStrig <- "https://djwillichile.github.io/MODULO_05/DATA/bradypus.xlsx"

# Leemos el archivo temporal mediante la función "read_excel"
bradypus <- read.xlsx(fileStrig,1)
head(bradypus)
```

<br>
  Es posible apreciar que el objeto `bradypus` es un data.frame común y que no constituye un objeto de tipo espacial
```{r}
class(bradypus)
```
<br>
  Es importante precisar que los datos puntuales requieren contar con al menos 2 variables correspondientes a las coordenadas geográficas verticales (*latitud*) y horizontales (*longitud*), a las que adicionalmente se les puede incluir una tercera variable correspondiente a la coordenada ortogonal de altura (*altitud*). Para este ejemplo es posible apreciar que contamos con la variable horizontal y vertical de coordenadas, *lon* y *lat* respectivamente.

```{r,echo = F}
library(knitr)
kable(head(bradypus), align ="c")

```
## Crear capas espaciales de puntos
  Para crear objetos espaciales a partir de matrices o data.frames con coordenadas espaciales es posible utilizar las funciones `SpatialPoints()`,`SpatialPointsDataFrame()` o `coordinates()`. Es preciso mencionar que para utilizar dichas funciones es necesario llamar al paquete `sp` el cual se carga automáticamente al llamar a los paquetes `raster` y/o `rgdal`. También es necesario que las coordenadas espaciales se encuentren registradas en un único sistema de referencia con su respectivo DATUM y tener muy claro a cual corresponde para evitar problemas al momento de georreferenciar las coordenadas.


```{r, fig.align='center'}
# Cargamos paquetes espaciales
library(raster)
library(rgdal)
library(maptools)

# importamos una capa espacial del mundo para contextualizar
data(wrld_simpl)
par(mar = c(2, 2, 0.1, 0.1))

# Creamos el objeto espacial "bradypus.sp" donde proj4string corresponde al sistema de referencia
bradypus.sp <- SpatialPoints(bradypus[c("lon","lat")], proj4string=crs("+init=epsg:4326"))
bradypus.sp

# graficamos el objeto espacial, cosa que no era posible hacer con el data.frame
plot(bradypus.sp,axes=T,col="blue")

# añadimos a la gráfica la capa espacial del mundo
plot(wrld_simpl,add=T)

# realizamos el mismo procedimiento con la función "SpatialPointsDataFrame"
bradypus.sp2 <- SpatialPointsDataFrame(bradypus[c("lon","lat")], data = bradypus["species"], proj4string=crs("+init=epsg:4326"))
bradypus.sp2

# graficamos
plot(bradypus.sp2,axes=T,col="red")
plot(wrld_simpl,add=T)

# ahora realizamos el mismo procedimiento con la función "coordinates"
bradypus.sp3 <- bradypus
coordinates(bradypus.sp3) <- ~lon+lat
crs(bradypus.sp3)=crs("+init=epsg:4326")
bradypus.sp3

# graficamos
plot(bradypus.sp3,axes=T,col="forestgreen")
plot(wrld_simpl,add=T)
```
<br>
  Cómo habrán podido notar, los 3 métodos permiten obtener resultados muy parecidos utilizando a su vez una sintaxis simple que no requiere mayor análisis, es decir, se requiere la base de datos con coordenadas y el sistema de referencia, la principal diferencia radica en que la función `SpatialPoints()` devuelve solo las coordenadas espaciales georreferenciadas mientras que las otras 2 georeferencian todo el contenido de la base de datos.
  
## Importar capas vectoriales
Ya aprendimos como importar información y crear capas vectoriales a partir de bases de datos puntuales, pero en el mundo del análisis espacial se manejan distintos formatos y archivos con los que van a toparse de vez en cuando, algunos de estos formatos con los ya mencionados *shp* y *kml*, por suerte existen paquetes para importar y manipular dichos archivos, una de las funciones más utilizadas para cargar estos archivos `readOGR()` del paquete `rgdal`

```{r , include=FALSE}
dev.off(dev.list())
```

```{r, fig.align='center'}
# Asignamos al objeto "fileStrig" ruta completa del archivo kml
fileStrig <- "https://djwillichile.github.io/MODULO_05/DATA/bradypus.kml"

# importamos la capa mediante la función "readOGR"
bradypus <- readOGR(fileStrig,layer = "bradypus")
bradypus

# graficamos
par(mar = c(2, 2, 0.1, 0.1))
plot(bradypus.sp2,axes=T,col="blue")
plot(wrld_simpl,add=T)

```
<br>
Como ya habrán visto, la importación de estos datos espaciales sigue el mismo patrón, la función `readOGR()` requiere el nombre del archivo y algunas veces la codificación de este para que no se desconfigure la base de datos no espacial asociada al archivo, de todos modos podrán revisar el detalle de esta función incorporando un sigo de interrogación antes de la función (`?readOGR()`) u ocupando la función help (`help("readOGR")`)
